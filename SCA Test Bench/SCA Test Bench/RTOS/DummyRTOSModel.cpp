#ifdef __CODESONAR__ 

/*
 *      Copyright (c) 2001-2013, an unpublished work by GrammaTech, Inc.
 *                      ALL RIGHTS RESERVED
 *
 *      This software is furnished under a license and may be used and
 *      copied only in accordance with the terms of such license and the
 *      inclusion of the above copyright notice.  This software or any
 *      other copies thereof may not be provided or otherwise made
 *      available to any other person.  Title to and ownership of the
 *      modifications and additions to the  Wisconsin Alumni Research
 *      Foundation software is retained by GrammaTech, Inc.
 */

/*****************************************************************************
 *
 * This file was generated.  Do not edit this file -- changes will be lost.
 * 
 * This file contains model bodies for selected library functions.
 * The code is not intended to be correct in the sense that the correct
 * values are computed, but strives to model functions well enough for
 * client analyses.
 *
 * See the documentation in the release for information about how to
 * write a model body.
 *
 *****************************************************************************/


#include "csonar.h"

/****************************************************************************/

/* A function from VxWorks' semLib. */

/* Note that we do not model task blocking and unblocking here. */

/* Note that timing out is not really modeled here. */

#include "DummyRTOS.h"

TASK_ID	threadSpawn(char * name, int priority, int options,	OS_size_t stackSize, INT_FUNCPTR_INT entryPt, OS_usr_arg_t arg1)
{
	 csonar_thread_create( (csonar_thread_entry_fn_t)entryPt,
                          (void *)arg1 );
	 return 1;
}

STATUS semaphoreTake( SEMAPHORE_ID sem, OS_ticks_t timeout )
{
     char dead;
   
    dead = ((char *)sem)[0];
    if( timeout == OS_WAIT_FOREVER )
    {
        csonar_mutex_pre_acquire( (void*)sem );
		csonar_mutex_acquire( (void*)sem  );
		return OK;
    }
    else
    {
		STATUS rv = -( !CSM_UNKNOWN_INTEGER() );
		if(rv != ERROR)
		{
			csonar_mutex_pre_acquire( (void*)sem );
			csonar_mutex_acquire( (void*)sem  );
		}
		return rv;
    }
    return ERROR;
}

SEMAPHORE_ID semaphoreCreateBinary(SEMAPHORE_BINARY_STATE initialState)
{
	return (SEMAPHORE_ID)CSM_UNKNOWN_INTEGER();
}

STATUS semaphoreGive( SEMAPHORE_ID sem )
{
    csonar_mutex_pre_release( (void*)sem );
    csonar_mutex_release( (void*)sem );
	return OK;
}
STATUS interruptConnect(void * vectorAddr, VOID_FUNCPTR_INT routine, OS_usr_arg_t parameter)
{
	csonar_sighand_create((csonar_thread_entry_fn_t)routine, (void*)parameter);   /* Call csonar_sighand_create() on success path. */
    return OK;
}

STATUS interruptEnable(int vector)
{
	return OK;
}

SPINLOCK_ISR_ID spinLockIsrCreate()
{
	return (SPINLOCK_ISR_ID)CSM_UNKNOWN_INTEGER();
}
void spinLockIsrGive(SPINLOCK_ISR_ID * lock)
{
	csonar_mutex_pre_release( (void*)lock );
    csonar_mutex_release( (void*)lock );
}

void spinLockIsrTake(SPINLOCK_ISR_ID * lock)
{
	csonar_mutex_pre_acquire( (void*)lock );
	csonar_mutex_acquire( (void*)lock  );
}

#endif